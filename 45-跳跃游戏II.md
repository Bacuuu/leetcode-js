## 题目描述

> [跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)
>
>题目简述
>
>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
>数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
>你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
>假设你总是可以到达数组的最后一个位置。
>
>示例 1:
> - 输入: nums = [2,3,1,1,4]
> - 输出: 2
> - 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

## 分类
`中等` `贪心` `动态规划`

## 思路
#### 思路1
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
  nums = nums.reverse()
  const dp = [0]
  for(let i = 1; i < nums.length; i ++) {
    dp[i] = Math.min(...dp.slice(Math.max(i - nums[i], 0), i)) + 1
  }
  return dp[nums.length - 1]
};
```
- 问题分析
  - 该题使用动态规划求解，整体思路如下
    - `dp[i]`储存从该位置能够到达最后一个位置最小的步数。
    - 求解顺序是从数组尾部开始，往前推导，因为对于一个位置而言，我们能够知道的是该位置可能到达的位置(`i -> i + nums[i]`)，所以该位置跳跃到最后位置必定经过这些位置。所以如果我们知道这些位置到达最后位置的最小步数，我们能推导`dp[i] = Math.min(...dp.slice(Math.max(i - nums[i], 0), i)) + 1`，在能够到达的位置的最小步数基础上多一步。
    - 这里我们先将`nums`倒序排列，便于我们进行正向遍历，所以这里需要注意`i`的实际意义。
    - 关于`dp[0] = 0`，这里`dp[0]`代表最后一个格子的步数，因为就是它本身，所以只需要走`0`步，既符合本身的意义，也能够保证推导的正确性。