## 题目描述

> [解码方法](https://leetcode-cn.com/problems/decode-ways/)
>
>题目简述
>
>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
> - 'A' -> 1
> - 'B' -> 2
> - ...
> - 'Z' -> 26
>
> 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
> - "AAJF" ，将消息分组为 (1 1 10 6)
> - "KJF" ，将消息分组为 (11 10 6)
>
>注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
>
>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
>
>题目数据保证答案肯定是一个 32 位 的整数。

## 分类
`中等` `动态规划` 

## 思路
#### 思路1
```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
  if (s[0] === '0') {
    return 0
  }
  const dp = [1]
  for (let i = 1; i<= s.length; i++) {
    // 单个字符解码
    dp[i] = 0
    // 当前不为 0
    if (s[i - 1] !== '0') {
      dp[i] += dp[i - 1]
    }
    // 前一个不为 0
    if (i > 1 && s[i - 2] !== '0' && parseInt(s[i - 2] + s[i - 1]) < 27) {
      dp[i] += dp[i - 2]
    }
  }
  return dp[s.length]
};
```
- 问题分析
  - 该题的难点在于递推的过程，如果新增一个字符是可以通过前两个字符进行推断的，具体逻辑如下：
    - 该字符单独成为一个字母的情况，只有当新增的字符不为`0`时，可以看作将新增的作为一个字母。此时的分组情况和不添加该字符的情况数量相等(`dp[i - 1]`)。
    - 能够和前一个字符组合成新字符的情况，这种情况的前提是前一个字符不为`0`（因为`01`这种是无效的），而且这两个字符组合后，应该是位于`1 - 26`的。该种情况数量为去除前一个字符的情况的数量(`dp[i - 2]`)
    - 这里将`i`初始化为`1`，可以理解为整体后移了一位，方便对第一个值初始化，方便递推，所以`dp[i]`是指第`i`个字符前（从`0`开始算）的解码方法总数。
  - 再多考虑第一个字符为`0`的情况，无法解析，直接返回0
